/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

/**
 * @author Igor Ostapenko
 */
'use strict';

const assert = require('assert');
const { mapSerializer } = require('../../../lib/structure/io/binary/GraphBinary');

const Bytecode = require('../../../lib/process/bytecode');
const { GraphTraversal } = require('../../../lib/process/graph-traversal');
const g = () => new GraphTraversal(undefined, undefined, new Bytecode());

const { from, concat } = Buffer;

describe('GraphBinary.MapSerializer', () => {

  describe('serialize', () => {
    [
      { v: undefined, fq: true,  e: [0x0A, 0x01] },
      { v: undefined, fq: false, e: [            0x00,0x00,0x00,0x00] },
      { v: null,      fq: true,  e: [0x0A, 0x01] },
      { v: null,      fq: false, e: [            0x00,0x00,0x00,0x00] },
      // the following will be automatically tested for fq=false/true
      { v: {},
        e: [0x00,0x00,0x00,0x00] },
      { v: { 'a': 'a' },
        e: [0x00,0x00,0x00,0x01, /*'a'*/0x03,0x00,0x00,0x00,0x00,0x01,0x61, /*'a'*/0x03,0x00,0x00,0x00,0x00,0x01,0x61] },
      { v: { 'a': 'A' },
        e: [0x00,0x00,0x00,0x01, /*'a'*/0x03,0x00,0x00,0x00,0x00,0x01,0x61, /*'A'*/0x03,0x00,0x00,0x00,0x00,0x01,0x41] },
      { v: { 'a': 1 },
        e: [0x00,0x00,0x00,0x01, /*'a'*/0x03,0x00,0x00,0x00,0x00,0x01,0x61, /*1*/0x01,0x00,0x00,0x00,0x00,0x01] },
      { v: { 'yz': 'A1' },
        e: [0x00,0x00,0x00,0x01, /*'yz'*/0x03,0x00,0x00,0x00,0x00,0x02,0x79,0x7A, /*'A1'*/0x03,0x00,0x00,0x00,0x00,0x02,0x41,0x31] },
      { v: { 'one': 1, 'two': 2 },
        e: [0x00,0x00,0x00,0x02,
          /*'one'*/0x03,0x00,0x00,0x00,0x00,0x03,0x6F,0x6E,0x65, /*1*/0x01,0x00,0x00,0x00,0x00,0x01,
          /*'two'*/0x03,0x00,0x00,0x00,0x00,0x03,0x74,0x77,0x6F, /*2*/0x01,0x00,0x00,0x00,0x00,0x02,
        ]
      },
      { v: { 'one': 1, 'two': 2, 'int32': { 'min': -2147483648, 'max': 2147483647 } },
        e: [0x00,0x00,0x00,0x03,
          /*'one'*/0x03,0x00,0x00,0x00,0x00,0x03,0x6F,0x6E,0x65, /*1*/0x01,0x00,0x00,0x00,0x00,0x01,
          /*'two'*/0x03,0x00,0x00,0x00,0x00,0x03,0x74,0x77,0x6F, /*2*/0x01,0x00,0x00,0x00,0x00,0x02,
          /*'int32'*/ 0x03,0x00, 0x00,0x00,0x00,0x05, 0x69,0x6E,0x74,0x33,0x32,
          /*int32 map*/
          0x0A,0x00, 0x00,0x00,0x00,0x02,
            /*'min'*/0x03,0x00,0x00,0x00,0x00,0x03,0x6D,0x69,0x6E, /*-2147483648*/0x01,0x00,0x80,0x00,0x00,0x00,
            /*'max'*/0x03,0x00,0x00,0x00,0x00,0x03,0x6D,0x61,0x78, /* 2147483647*/0x01,0x00,0x7F,0xFF,0xFF,0xFF,
        ]
      },
      { v: { aliases: {g:'g'}, gremlin: g().V().getBytecode() },
        e: [0x00,0x00,0x00,0x02,
          /*'aliases'*/
          0x03,0x00, 0x00,0x00,0x00,0x07, ...Buffer.from('aliases'),
          /*aliases map*/
          0x0A,0x00, 0x00,0x00,0x00,0x01,
            /*'g'*/0x03,0x00,0x00,0x00,0x00,0x01,0x67, /*'g'*/0x03,0x00,0x00,0x00,0x00,0x01,0x67,

          /*'gremlin'*/
          0x03,0x00, 0x00,0x00,0x00,0x07, ...Buffer.from('gremlin'),
          /*gremlin bytecode*/
          0x15,0x00,
            // {steps_length}
            0x00,0x00,0x00,0x01,
              // step 1 - {name} String
              0x00,0x00,0x00,0x01,  ...Buffer.from('V'),
              // step 1 - {values_length} Int
              0x00,0x00,0x00,0x00,
            // {sources_length}
            0x00,0x00,0x00,0x00,
        ]
      },
    ].forEach(({ v, fq, e }, i) => it(`should be able to handle value of case #${i}`, () => {
      if (fq !== undefined) {
        assert.deepEqual( mapSerializer.serialize(v, fq), Buffer.from(e) );
        return;
      }
      assert.deepEqual( mapSerializer.serialize(v, false), Buffer.from(e) );
      assert.deepEqual( mapSerializer.serialize(v, true), Buffer.concat([Buffer.from([0x0A,0x00]), Buffer.from(e)]) );
    }));
  });

  describe('deserialize', () =>
    it.skip('')
  );

  describe('canBeUsedFor', () =>
    it.skip('')
  );

});
